<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Structex - structural regular expressions for Rust"><title>structex - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="structex" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate structex</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../structex/index.html">structex</a><span class="version">0.4.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#structex---structural-regular-expressions-for-rust" title="Structex - structural regular expressions for Rust">Structex - structural regular expressions for Rust</a><ul><li><a href="#documentation" title="Documentation">Documentation</a></li><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#what-are-structural-regular-expressions" title="What are structural regular expressions?">What are structural regular expressions?</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>structex</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/structex/lib.rs.html#1-40">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="structex---structural-regular-expressions-for-rust"><a class="doc-anchor" href="#structex---structural-regular-expressions-for-rust">§</a>Structex - structural regular expressions for Rust</h2>
<p><a href="https://github.com/sminez/structex/actions?query=workflow%3ABuild"><img src="https://github.com/sminez/structex/workflows/Build/badge.svg" alt="Build" /></a>
<a href="https://crates.io/crates/structex"><img src="https://img.shields.io/crates/v/structex" alt="crates.io version" /></a>
<a href="https://docs.rs/structex"><img src="https://img.shields.io/docsrs/structex?logo=rust" alt="docs.rs" /></a></p>
<p>This crate provides a generic structural regular expression engine that can be
backed by a user provided regular expression engine. Support for using the
<a href="https://docs.rs/regex/latest/regex/index.html">regex</a> crate is provided from this crate under the <code>regex</code> feature.</p>
<h3 id="documentation"><a class="doc-anchor" href="#documentation">§</a>Documentation</h3>
<p>This crate’s public API is documented in <a href="https://docs.rs/structex">docs.rs</a>.</p>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3>
<p>To add this crate to an existing Rust project, either add <code>structex</code> to your
<code>Cargo.toml</code> or run <code>cargo add structex</code>. By default, support for using the
<a href="https://docs.rs/regex/latest/regex/index.html">regex</a> crate as a back end is enabled via the <code>regex</code> feature. You can
opt out of this by disabling default features.</p>
<p>The following is an example of how to find Rust functions that return Result
types from a given source file:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::Regex;
<span class="kw">use </span>structex::Structex;

<span class="comment">// Compile the structex using the regex crate as the underlying engine.
</span><span class="kw">let </span>se: Structex&lt;Regex&gt; = Structex::new(<span class="string">r#"
  x/fn(?:.|\n)*?\{/                   # select all Rust function signatures up to the opening brace
  g/-&gt;.*Result.*\{/                   # keep those that return some form of Result
  n/fn (\w+)(?:.|\n)*?-&gt; (.*?) \{/    # extract the function name and return type from the signature
"#</span>).unwrap();

<span class="comment">// Match against the ast.rs rust file from this crate
</span><span class="kw">let </span>haystack = <span class="macro">include_str!</span>(<span class="string">"src/ast.rs"</span>);

<span class="comment">// Print out the two capture groups along with the byte offsets of the match position.
</span><span class="kw">for </span>m <span class="kw">in </span>se.iter_tagged_captures(haystack) {
    <span class="kw">let </span>fn_name = m.submatch_text(<span class="number">1</span>).unwrap();
    <span class="kw">let </span>ret_ty = m.submatch_text(<span class="number">2</span>).unwrap();
    <span class="macro">println!</span>(<span class="string">"{}:{} {fn_name}: {ret_ty}"</span>, m.from(), m.to(),);
}</code></pre></div><h3 id="what-are-structural-regular-expressions"><a class="doc-anchor" href="#what-are-structural-regular-expressions">§</a>What are structural regular expressions?</h3>
<p>Introduced by Rob Pike in his <a href="http://doc.cat-v.org/plan_9/4th_edition/papers/sam/">Sam</a> text editor and discussed in his <a href="http://doc.cat-v.org/bell_labs/structural_regexps/">1987
paper</a>, structural regular expressions provide a notation and semantics for
composing <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a> in order to more easily describe the
<em>structure</em> of the text being searched. The syntax used by Pike in <code>Sam</code>
combined looping constructs and conditional expressions with printing and
editing actions such as deleting the matched text, inserting before or after
the match and replacing the match entirely.</p>
<p>There have been a handful of other implementations over the years, notably
Pike’s later editor <a href="http://acme.cat-v.org/">acme</a>, <a href="https://github.com/martanne/vis">vis</a> and my own editor <a href="https://github.com/sminez/ad">ad</a>, all of which
follow the original approach of coupling the composition operators with editing
actions that are applied to each match.</p>
<p>A goal of this crate is to propose a new way of working with structural regular
expressions by splitting the problem into two parts:</p>
<ol>
<li>Locating and refining matches.</li>
<li>Applying actions to each match.</li>
</ol>
<p>Doing so allows for a common implementation of the structural matching element
that can then be used to implement a wide range of functionality based on the
actions assigned to each match. Effectively ending up with a regex engine that
supports <code>flat_map</code> and <code>filter</code> style operations on matches as part of the
matching behaviour itself.</p>
<h4 id="locating-and-refining-matches"><a class="doc-anchor" href="#locating-and-refining-matches">§</a>Locating and refining matches</h4>
<p>This side of the problem is effectively a subset of the original structural
regular expressions, and the primary focus of this crate, where we define a set
of operators that allow for breaking apart and filtering the current match. In
order to start matching we first set the current <code>dot</code> (selected text) to the
full input and then accept a chain of one or more of the following operators:</p>
<ul>
<li><code>x/$re/</code> “extract” and iterate over all non-overlapping matches of <code>$re</code>
within the current dot.</li>
<li><code>y/$re/</code> “split” the current dot using <code>$re</code> as the delimiter and iterate
over the resulting substrings.</li>
<li><code>n/$re/</code> “narrow”<sup id="fnref1"><a href="#fn1">1</a></sup> the current dot to the first match of <code>$re</code>
within it.</li>
<li><code>g/$re/</code> “guard” the rest of the following chain on <code>$re</code> matching dot.</li>
<li><code>v/$re/</code> “inverse guard” the rest of the following chain on <code>$re</code> <em>not</em>
matching dot.</li>
</ul>
<p>With these operators defined we can write expressions that combine them in
a variety of interesting ways. For example, the following expression breaks
the input into sentences delimited by <code>.</code>, keeps sentences that contain the
substring <code>Alice</code> and then narrows to the last word in the sentence as a
submatch:</p>
<div class="example-wrap"><pre class="language-text"><code>x/(.|\n)*?\./ g/Alice/ n/(\w+)\./</code></pre></div>
<p>Running such an expression over the following text:</p>
<div class="example-wrap"><pre class="language-text"><code>This is a multi-line string that mentions peoples names. People like Alice
and Bob. People like Claire and David, but really we&#39;re here to talk about
Alice. Alice is everyone&#39;s friend.</code></pre></div>
<p>Would extract the words <code>Bob</code>, <code>Alice</code> and <code>friend</code> in order as the final
submatch from the “narrow” expression.</p>
<p>That’s already quite powerful and expressive but there is one more piece of
syntax that we define which allows us to do some <em>really</em> interesting things.</p>
<p>We define a parallel “group” to be an ordered list of expressions that are run
over same initial dot rather than sequentially refining each match position.
To distinguish this from a normal expression chain, the group as a whole is
wrapped in curly braces and each “branch” is terminated with a semi-colon. It
is a syntax error to have an empty group or to omit the semi-colon at the end
of a branch.</p>
<p>A group such as the following would run each expression in parallel over the
entire input, interleving matches from each branch as they are found:</p>
<div class="example-wrap"><pre class="language-text"><code>{
  # if dot contains &quot;Alice&quot; extract the last word before a &#39;.&#39;
  g/Alice/ n/(\w+)\./;

  # if it doesn&#39;t, extract the first word of dot instead
  v/Alice/ n/(\w+)/;
}</code></pre></div>
<p>Running this against our input from before will produce <code>names</code>, as we are
running over the entire input and that is the leftmost-longest match of the
“narrow” regex <code>(\w+)\.</code>.</p>
<p>If we add a group to the end of an expression chain then it runs for each
match produced by the chain. So, if we add back our “extract” for splitting
the input into sentences:</p>
<div class="example-wrap"><pre class="language-text"><code>x/(.|\n)*?\./ {
  g/Alice/ n/(\w+)\./;
  v/Alice/ n/(\w+)/;
}</code></pre></div>
<p>We’ll get <code>This</code> (a new match) followed by <code>Bob</code>, <code>Alice</code> and <code>friend</code> that
we had before, as we are now running our parallel group over each sentence
individually.</p>
<p>This combination of guards and parallel groups allows us to conditionally
extract different substrings based on the surrounding structure, but at a
cost: we now don’t know which branch matched inside of the parallel group.
To address that, we need to address the other half of the problem: applying
actions to matches.</p>
<h4 id="applying-actions"><a class="doc-anchor" href="#applying-actions">§</a>Applying actions</h4>
<p>The expressions shown above have no explicit action assigned to them, so
they will result in the default action of simply emitting the match. If
we instead assign an “action” tag to the end of each branch, that action
will be emitted alongside each match coming from that branch:</p>
<div class="example-wrap"><pre class="language-text"><code>x/(.|\n)*?\./ {
  g/Alice/ n/(\w+)\./ A;
  v/Alice/ n/(\w+)/ B;
}</code></pre></div>
<p>Now we will see an <code>A</code> tag when we match the first branch and a <code>B</code> tag
when we match the second. Running again over our input we will get both
the matches themselves <em>and</em> their associated tag: <code>("This", 'B')</code>,
<code>("Bob", 'A')</code>, <code>("Alice", 'A')</code> and <code>("friend", 'A')</code>.</p>
<p>Actions can also have an associated “argument” enclosed in slashes. This
is useful for defining tags that control the type of action to be taken
(for example <code>p</code> for printing) and then an additional argument that can
be used alongside the match in order to handle the action (such as a
template string). See the <a href="https://github.com/sminez/structex/blob/main/examples/templated_printing.rs">templated_printing</a> example in the repo for
a demonstration of how this can be implemented for a more complicated
expression that uses multiple different template strings.</p>
<div class="footnotes"><hr><ol><li id="fn1"><p>The <code>n</code> narrowing operator is a new edition to the syntax added by
this crate. In Pike’s original system this narrowing was possible via “address”
expressions that set dot using a rich syntax that made use of both regular
expressions and Sam’s editor state for the file being manipulated. In order to
keep the syntax consistent I have opted to make this an explicit operator and
only support narrowing the current dot to a substring rather than extending
both forward and backward (which also prevents some further issues and
restrictions within the implementation).&nbsp;<a href="#fnref1">↩</a></p></li></ol></div></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.Captures"><code>pub use re::<a class="struct" href="re/struct.Captures.html" title="struct structex::re::Captures">Captures</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="re/index.html" title="mod structex::re">re</a></dt><dd>The required interface for an underlying regex engine</dd><dt><a class="mod" href="template/index.html" title="mod structex::template">template</a></dt><dd>Simple template parsing and rendering for use in actions.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Action.html" title="struct structex::Action">Action</a></dt><dd>A tag with optional argument attached to a match position as part of a <a href="struct.Structex.html" title="struct structex::Structex">Structex</a>.</dd><dt><a class="struct" href="struct.Structex.html" title="struct structex::Structex">Structex</a></dt><dd>A compiled structural regular expression backed by an underlying regular expression engine.</dd><dt><a class="struct" href="struct.StructexBuilder.html" title="struct structex::StructexBuilder">Structex<wbr>Builder</a></dt><dd>A configurable builder for a <a href="struct.Structex.html" title="struct structex::Structex">Structex</a>.</dd><dt><a class="struct" href="struct.TaggedCaptures.html" title="struct structex::TaggedCaptures">Tagged<wbr>Captures</a></dt><dd>Represents a tagged capture group for a single match position located by a <a href="struct.Structex.html" title="struct structex::Structex">Structex</a>.</dd><dt><a class="struct" href="struct.TaggedCapturesIter.html" title="struct structex::TaggedCapturesIter">Tagged<wbr>Captures<wbr>Iter</a></dt><dd>An iterator over all matches in a haystack.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum structex::Error">Error</a></dt><dd>An error that occurred during parsing or compiling a strutural regular expression.</dd><dt><a class="enum" href="enum.ErrorKind.html" title="enum structex::ErrorKind">Error<wbr>Kind</a></dt><dd>A list specifying the different categories of errors that can be encountered while parsing a
structural regular expression.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.ParseError.html" title="type structex::ParseError">Parse<wbr>Error</a></dt><dd>An error that can arise during expression parsing.</dd></dl></section></div></main></body></html>